Programmablaufplan
==================

[A] calc7st.m {INP: p_target,jmax,amax,vmax,a0,v0,p0} {OUT: [t,j]}
	Berechnung des zeitoptimalen Bewegungsprofils mit Jerk-Impulsen von
	j_max, bzw. -j_max. Zurückgegeben werden n Zeitintervalle mit den dazu-
	gehoerigen jerk-Werten. (1<=n<=8, Normalfall: n=7)
	
	(1) Teste, ob a0 > amax. Falls ja, füge dec-Phase ein und rufe [A]
	rekursiv mit den neuen Startwerten auf
	
	(2) Teste, ob bei sofortigem Reduzieren der Beschleunigung auf Null vmax
	überschritten wird. Falls ja, füge dec-Phase ein und rufe [A] rekursiv mit
	den neuen Startwerten auf.
	
	(3) Berechne das direction-flag anhand der sich ergebenden Endposition
	bei einem sofortigem Abbremsen auf Null.
	
	(4) Berechne mit [B] den Verlauf der Bewegung bei schnellstmöglichem
	Erreichen von vmax und anschließendem schnellstmöglichen Abbremsen auf
	Null. (Cruising-Phase Fall mit t_cruise = 0)
	Anhand des Verlaufs wird t_cruise berechnet - die Länge der Cruising-
	phase, um ptarget genau zu erreichen.
	
	(5) Ist t_cruise>=0, so ist das gesuchte Profil gefunden und wird zurück-
	gegeben, ansonsten wird [C] aufgerufen.
	
[B] calc3st.m {INP: p_target,amax,vmax,v0,p0} {OUT: [t, a]}
	Berechnung des zeitoptimalen Bewegungsprofil mit Beschleunigungsimpulsen
	von a_max, bzw. -a_max. Zurückgegeben werden 3 Zeitintervalle mit den
	dazugehörigen acc-Werten.
	
[C] calc7st_nocruise.m {INP: dp,t,dir,trapezoid_stop,ptarget,jmax,amax,vmax,a0,v0,p0} {OUT: [t, j]}
	Berechnung des zeitoptimalen Bewegungsprofils mit Jerk-Impulsen von
	j_max, bzw. -j_max im Falle einer Bewegung ohne cruising-Phase (= Phase
	mit v = +-vmax und a=0).
	Als Input erhält die Funktion neben den Begrenzungen und Startwerten von
	j, a, v und p sowie der Richtung der "hypothetischen" cruising Phase auch
	noch die Zeiten für ein Bewegunsprofil in dem erst die Maximalgeschwindig-
	keit erreicht wird und dann sofort auf Null abgebremst wird (Grenzfall
	cruising-Phase-Zeit=0).
	Da es sich aber um eine Bewegung ohne cruising-Phase handelt, wird die
	Bewegung überschießen (ein- oder zweimal, je nach dir-Flag). Die Strecke
	die zuviel zurückgelegt wird, wird in 'dp' übergeben.
	Zurückgegeben werden n Zeitintervalle mit den dazugehoerigen jerk-Werten.
	(2<=n<=7, Normalfall: n=6)
	
	(1) Teste, ob v0 > vmax. Falls ja, füge eine dec-Phase ein und rufe [A]
	rekursiv mit den neuen Startwerten auf.
	
	(2) Fallunterscheidung in die möglichen Profile DD, DT, TD, TT anhand
	des übergebenen Bewegungsprofils einer v0->vmax->0 Bewegung:
		(2a) DD-Profil. Bei v0>vmax ist DD und DT möglich, ansonsten nur
		     DD. Es wird dementsprechend entweder 
		     'calc7st_nocruise_dt_or_dd' oder dirket 'calc7st_nocruise_dd'
		     aufgerufen.
		(2b) DT-Profil. Es wird sich entweder ein DD oder DT Profil ergeben
		     'calc7st_nocruise_dt_or_dd' wird aufgerufen.
		(2c) TD-Profil. Es wird sich entweder ein DD oder DT Profil ergeben
		     'calc7st_nocruise_td_or_dd' wird aufgerufen.
	
	(3) = (2d) TT-Profil. Im Falle eines TT-Profils kann aus den beiden
	a=amax Phasen jeweils ein Zeitstück dt herausgeschnitten werden, so dass
	genau dp Strecke weniger zurückgelegt wird.
	Allerdings kann es dabei dazu kommen, dass eine oder beider der a=amax
	Phasen kürzer als dt sind und wir somit in einen DD/DT/TD Fall kommen.
	Daher folgende Fallunterscheidung:
		(3a) Beide a=amax Phasen lang genug. Rückgabe der ber. Bewegung.
		(3b) Erste der beiden Phasen kürzer als die zweite. Aufruf von
		     'calc7st_nocruise_dt_or_dd' bzw. 'calc7st_nocruise_dt', je
		   nachdem, ob dt <= zweite Phase.
		(3c) Zweite der beiden Phasen kürzer als die erste. Aufruf von
		     'calc7st_nocruise_td_or_dd' bzw. 'calc7st_nocruise_td', je
		   nachdem, ob dt <= erste Phase.
		   
[D] calc7st_nocruise_dd.m {INP: dir,ptarget,jmax,amax,vmax,a0,v0,p0} {OUT: [t, j]}
	Diese Funktion berechnet durch das numerische Auffinden der Nullstellen des
	Lösungspolynoms (aus 'formulars_7stp_DD_bruteforce.m') das korrekte DD-Profil.
	Mit dem Polynom wird t3 numerisch ermittelt, daraus werden dann t2 and t1 be-
	rechnet.
	Zurückgegeben werden 3 Zeitintervalle mit den dazugehoerigen jerk-Werten.
		(1) Spezialfall: Falls v0 Richtung Ziel, a0 entgegen dieser Richtung
		zeigt, und wir nicht zuerst die Beschleunigung auf Null reduzieren
		können, da wir sonst doch über das Ziel schießen würden - dann muss
		in der Gleichung zur Berechnung von t2 und t1 das Vorzeichen umgedreht
		werden.
		
		(2) Alle Nullstellen des Polynoms für t3 finden.
		
		(3) Die beste/korrekten Lösungen finden (z.T. ergeben sich mehrere
		(Schein-)Lösungen, da das Polynom durch Quadrieren aus der Orginalformel
		hervorgegangen ist.
		
[E] calc7st_nocruise_dt.m {INP: dir,ptarget,jmax,amax,vmax,a0,v0,p0} {OUT: [t, j]}
	Diese Funktion berechnet durch das numerische Auffinden der Nullstellen des
	Lösungspolynoms (aus 'formulars_7stp_DT_bruteforce.m') das korrekte DD-Profil.
	Mit dem Polynom wird t1 numerisch ermittelt, daraus werden dann t2, t3 und t4
	berechnet.
	Zurückgegeben werden 4 Zeitintervalle mit den dazugehoerigen jerk-Werten.
		(1) Die kleinste reelle, positive Nullstellen des Polynoms für t1 finden.
		
		(2) t2, t3 und t4 berechnen und zurückgeben.


[F] calc7st_nocruise_td.m {INP: dir,ptarget,jmax,amax,vmax,a0,v0,p0} {OUT: [t, j]}
	Diese Funktion berechnet durch das numerische Auffinden der Nullstellen des
	Lösungspolynoms (aus 'formulars_7stp_TD_bruteforce.m') das korrekte DD-Profil.
	Mit dem Polynom wird t4 numerisch ermittelt, daraus werden dann t1, t2 und t3
	berechnet.
	Zurückgegeben werden 4 Zeitintervalle mit den dazugehoerigen jerk-Werten.
		(1) Die kleinste reelle, positive Nullstellen des Polynoms für t4 finden.
		
		(2) t1, t2 und t3 berechnen und zurückgeben.